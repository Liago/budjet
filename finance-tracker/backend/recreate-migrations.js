// recreate-migrations.js
const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');
const dotenv = require('dotenv');

// Load production environment
process.env.NODE_ENV = 'production';
const envFile = '.env.production';

if (fs.existsSync(path.join(__dirname, envFile))) {
  console.log(`Loading environment from ${envFile}`);
  dotenv.config({ path: path.join(__dirname, envFile) });
} else {
  console.log('Using default .env file');
  dotenv.config();
}

async function recreateMigrations() {
  console.log('üöÄ Inizializzazione del processo di ricreazione delle migrazioni...');
  
  const migrationsPath = path.join(__dirname, 'prisma/migrations');
  const migrationLockPath = path.join(__dirname, 'prisma/migrations/migration_lock.toml');
  
  try {
    // Verifica che l'URL del database sia configurato per PostgreSQL
    if (!process.env.DATABASE_URL.includes('postgres')) {
      console.error('‚ùå Il DATABASE_URL deve puntare a PostgreSQL');
      console.error('Assicurati di usare l\'ambiente di produzione');
      process.exit(1);
    }
    
    // Elimina la directory delle migrazioni esistenti se presente
    if (fs.existsSync(migrationsPath)) {
      console.log('üóëÔ∏è Eliminazione delle migrazioni esistenti...');
      fs.rmSync(migrationsPath, { recursive: true, force: true });
      console.log('‚úÖ Directory delle migrazioni eliminata');
    }
    
    // Crea una nuova directory per le migrazioni
    fs.mkdirSync(migrationsPath, { recursive: true });
    
    // Crea un nuovo file migration_lock.toml per PostgreSQL
    fs.writeFileSync(
      migrationLockPath,
      '# Please do not edit this file manually\n# It should be added in your version-control system (e.g., Git)\nprovider = "postgresql"'
    );
    console.log('‚úÖ Creato nuovo file migration_lock.toml per PostgreSQL');
    
    // Genera nuove migrazioni basate sullo schema attuale
    console.log('üîÑ Generazione delle nuove migrazioni per PostgreSQL (solo creazione)...');
    
    // Esegui prisma migrate dev con --create-only per evitare la shadow database
    try {
      execSync('npx prisma migrate dev --name init --create-only', { 
        stdio: 'inherit',
        env: { ...process.env }
      });
      console.log('‚úÖ File di migrazione creati con successo');
      
      // Ora creiamo manualmente il database
      console.log('üîÑ Applicazione manuale della migrazione...');
      execSync('npx prisma db push --accept-data-loss --skip-generate', {
        stdio: 'inherit',
        env: { ...process.env }
      });
      console.log('‚úÖ Schema applicato con successo al database');
      
    } catch (error) {
      console.error('‚ùå Errore durante la creazione delle migrazioni:', error.message);
      console.log('üìù Tentativo alternativo con prisma db push...');
      
      try {
        // Approccio alternativo: usare prisma db push
        execSync('npx prisma db push --accept-data-loss', {
          stdio: 'inherit',
          env: { ...process.env }
        });
        console.log('‚úÖ Schema applicato con successo al database (usando db push)');
      } catch (pushError) {
        console.error('‚ùå Anche il tentativo alternativo √® fallito:', pushError.message);
        console.log('üìù Dovresti verificare che:');
        console.log('  1. DATABASE_URL nel file .env punti a un database PostgreSQL valido e accessibile');
        console.log('  2. Il database PostgreSQL sia in esecuzione e accessibile');
        console.log('  3. Lo schema Prisma sia valido per PostgreSQL');
        throw pushError;
      }
    }
    
    console.log('üéâ Processo completato con successo!');
    console.log('üìã Prossimi passi:');
    console.log('1. Importa i dati dal database SQLite (se necessario):');
    console.log('   node import-pg-data.js');
    
  } catch (error) {
    console.error('‚ùå Errore durante il processo:', error);
  }
}

recreateMigrations()
  .catch(e => {
    console.error('‚ùå Errore critico:', e);
    process.exit(1);
  });
